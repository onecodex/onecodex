# generated by datamodel-codegen:
#   filename:  https://app.onecodex.com/openapi.json
#   timestamp: 2025-07-10T18:39:05+00:00

"""
Auto-generated Pydantic models from One Codex OpenAPI specification.

DO NOT EDIT THIS FILE DIRECTLY!

This file is automatically generated from the OpenAPI spec at:
https://app.onecodex.com/openapi.json

To regenerate these models, run:
    python scripts/generate_models.py

For One Codex-specific extensions and functionality, see the other
files in the models/ directory.
"""

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class User(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/users/[a-f0-9]{16}$")


class AccountSchema(BaseModel):
    confirmed_at: str = Field(..., title="Confirmed At")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    email: str = Field(..., title="Email")
    user: User = Field(..., title="users")


class Dependency(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/analyses/[a-f0-9]{16}$")


class ErrorMsg(RootModel[str]):
    root: str = Field(
        ...,
        description="The error message from the analysis, if it failed.",
        max_length=255,
        title="Error Msg",
    )


class Job(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/jobs/[a-f0-9]{16}$")


class Sample(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/samples/[a-f0-9]{16}$")


class AnalysisFileDetailsSchema(BaseModel):
    filename: str = Field(..., description="The filename of the output file.", title="Filename")
    size: int = Field(..., description="File size in bytes.", ge=1, title="Size")
    url: str = Field(..., description="Pre-signed download URL.", title="Url")


class AnalysisFilesResponse(BaseModel):
    pass


class AnalysisRef(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/analyses/[a-f0-9]{16}$")


class AnalysisResultsResponse(BaseModel):
    pass


class ApiV1Visibility(Enum):
    public = "public"
    shared = "shared"
    private = "private"
    importing = "importing"
    awaiting_data = "awaiting data"


class ClassificationReadLevelResponse(BaseModel):
    url: str = Field(..., description="Pre-signed download URL.", title="Url")


class ControlResultsResponse(BaseModel):
    analysis_type: str = Field(..., title="Analysis Type")
    control_job: str = Field(..., title="Control Job")
    false_positive_orgs: Any = Field(..., title="False Positive Orgs")
    filename: str = Field(..., title="Filename")
    metrics: Any = Field(..., title="Metrics")
    product_code: str = Field(..., title="Product Code")
    true_positive_orgs: Any = Field(..., title="True Positive Orgs")


class CostSchema(BaseModel):
    amount: float = Field(..., title="Amount")
    currency: Literal["USD"] = Field("USD", title="Currency")


class DownloadPath(RootModel[str]):
    root: str = Field(
        ...,
        description="Directory into which to download the parent run (must be relative)",
        pattern="[^/].*",
        title="Download Path",
    )


class DependencyOverrideSchema(BaseModel):
    analysis: AnalysisRef = Field(..., description="Parent run to use as a dependency")
    download_path: Optional[DownloadPath] = Field(
        None,
        description="Directory into which to download the parent run (must be relative)",
        title="Download Path",
    )


class DocumentConfirmUploadSchema(BaseModel):
    document_id: str = Field(
        ...,
        description="The `document_id` returned by `/documents/init_upload`. Note that the document will not be accessible via `/documents/<id>` until the upload is confirmed.",
        title="Document Id",
    )


class DocumentDownloadSchema(BaseModel):
    download_uri: str = Field(..., description="The presigned download URL.", title="Download Uri")
    expires_in_hours: int = Field(
        ...,
        description="The number of hours the download URL will be valid.",
        title="Expires In Hours",
    )


class DocumentInitMultipartUploadResponse(BaseModel):
    callback_url: str = Field(..., title="Callback Url")
    file_id: str = Field(..., title="File Id")
    import_as_document: bool = Field(..., title="Import As Document")
    s3_bucket: str = Field(..., title="S3 Bucket")
    upload_aws_access_key_id: str = Field(..., title="Upload Aws Access Key Id")
    upload_aws_secret_access_key: str = Field(..., title="Upload Aws Secret Access Key")


class DocumentInitUploadResponse(BaseModel):
    additional_fields: Dict[str, Any] = Field(
        ...,
        description="Additional fields to include in the upload.",
        title="Additional Fields",
    )
    document_id: str = Field(
        ...,
        description="The `document_id` of the uploaded document.",
        title="Document Id",
    )
    upload_url: str = Field(..., description="The URL to POST the document to.", title="Upload Url")


class DocumentInitUploadSchema(BaseModel):
    filename: str = Field(
        ...,
        description="The filename of the document to be uploaded, optionally gzipped (and ending in `.gz` or `.gzip`). Filenames should only contain alphanumeric characters, dashes, underscores, and periods.",
        title="Filename",
    )
    size: int = Field(..., description="The size of the file in bytes.", ge=1, title="Size")


class DocumentRef(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/documents/[a-f0-9]{16}$")


class DocumentRenameSchema(BaseModel):
    filename: str = Field(..., title="Filename")


class Downloader(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/users/[a-f0-9]{16}$")


class Size(RootModel[int]):
    root: int = Field(..., description="The size of the document in bytes.", ge=1, title="Size")


class Uploader(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/users/[a-f0-9]{16}$")


class DocumentSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/documents/0d77065796f8d173"],
        pattern="^/api/v1/documents/[a-f0-9]{16}$",
        title="$Uri",
    )
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    description: Optional[str] = Field(None, description="ExcludeFromOpenAPI", title="Description")
    downloaders: List[Downloader] = Field(
        ...,
        description="An (optionally empty) array of references to users that the document has been shared with. These users are able to download (but not modify) the document.",
        title="Downloaders",
    )
    filename: str = Field(
        ..., description='The document filename (e.g., "report.pdf")', title="Filename"
    )
    size: Optional[Size] = Field(
        ..., description="The size of the document in bytes.", title="Size"
    )
    uploader: Uploader = Field(
        ...,
        description='A reference to the user that uploaded and owns the document, e.g., `{"$ref": "/api/v1/users/5891ee65711c4d5e"}`. Only owners can modify a document (with some exceptions in the case of organization accounts configured for multiple users - please [contact us](mailto:support@onecodex.com) if you\'d like to discuss this use case).',
        title="users",
    )
    valid_until: Optional[str] = Field(None, description="ExcludeFromOpenAPI", title="Valid Until")


class Status(Enum):
    success = "success"
    failed = "failed"
    pending = "pending"
    retryable = "retryable"


class EventSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/events/0d77065796f8d173"],
        pattern="^/api/v1/events/[a-f0-9]{16}$",
        title="$Uri",
    )
    payload: Dict[str, Any] = Field(..., description="The webhook payload.", title="Payload")
    status: Status = Field(
        ..., description="The status of the webhook for the event.", title="Status"
    )


class FunctionalRunSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/functional_profiles/0d77065796f8d173"],
        pattern="^/api/v1/functional_profiles/[a-f0-9]{16}$",
        title="$Uri",
    )
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")


class LocationLat(RootModel[float]):
    root: float = Field(
        ...,
        description="The latitude `(-90.0-90.0)` of the sample location. By convention, we recommend using this for the location in which the physical specimen was collected.",
        ge=-90.0,
        le=90.0,
        title="Location Lat",
    )


class LocationLon(RootModel[float]):
    root: float = Field(
        ...,
        description="The longitude `(-180.0-180.0)` of the sample location.",
        ge=-180.0,
        le=180.0,
        title="Location Lon",
    )


class LocationString(RootModel[str]):
    root: str = Field(..., max_length=255, title="Location String")


class Name(RootModel[str]):
    root: str = Field(..., max_length=255, title="Name")


class InlineTag(BaseModel):
    name: str = Field(
        ...,
        description="The tag label or name. Name must be 30 characters or fewer.",
        max_length=30,
        title="Name",
    )


class JobSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/jobs/0d77065796f8d173"],
        pattern="^/api/v1/jobs/[a-f0-9]{16}$",
        title="$Uri",
    )
    analysis_type: str = Field(
        ...,
        description="The type of analysis. See [the analysis resource](/api/analysis-resource) for more details.",
        title="Analysis Type",
    )
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    job_args_schema: Dict[str, Any] = Field(
        ...,
        description="The JSON schema for the arguments taken by the job (can be an empty object, i.e., `{}`).",
        title="Job Args Schema",
    )
    name: str = Field(
        ...,
        description="The name of the job (this is displayed in the dropdown on the analysis page of the One Codex web application).",
        title="Name",
    )
    public: bool = Field(
        ...,
        description="Whether the job is publicly available. For most jobs this will be `true`. Custom, private jobs are also available, and will only be visible to users whose samples (or samples shared with them) have been analyzed using that job.",
        title="Public",
    )


class PanelResultsResponse(BaseModel):
    panel_name: str = Field(..., title="Panel Name")
    panel_results: Any = Field(..., title="Panel Results")


class PanelSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/panels/0d77065796f8d173"],
        pattern="^/api/v1/panels/[a-f0-9]{16}$",
        title="$Uri",
    )
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")


class ProjectChangeSharingSchema(BaseModel):
    public: Optional[bool] = Field(
        False, description="Whether the project is public.", title="Public"
    )


class ProjectPatchSchema(BaseModel):
    description: Optional[str] = Field(None, title="Description")
    name: Optional[str] = Field(None, title="Name")
    project_name: Optional[str] = Field(None, title="Project Name")


class ProjectRef(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/projects/[a-f0-9]{16}$")


class Owner(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/users/[a-f0-9]{16}$")


class ProjectName(RootModel[str]):
    root: str = Field(
        ...,
        max_length=15,
        min_length=3,
        pattern="^[a-zA-Z0-9_-]{3,15}$",
        title="Project Name",
    )


class ProjectSchema(BaseModel):
    field_uri: str = Field(..., alias="$uri", title="$Uri")
    description: Optional[str] = Field(None, title="Description")
    external_id: Optional[str] = Field(None, examples=["a1b2c3d4e5f67890"], title="External Id")
    name: Optional[str] = Field(None, title="Name")
    owner: Optional[Owner] = Field(..., title="Owner")
    permissions: List[str] = Field(..., title="Permissions")
    project_name: Optional[ProjectName] = Field(..., title="Project Name")
    public: Optional[bool] = Field(False, title="Public")


class ReportSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/reports/0d77065796f8d173"],
        pattern="^/api/v1/reports/[a-f0-9]{16}$",
        title="$Uri",
    )
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")


class SampleCancelUploadResponse(BaseModel):
    message: str = Field(..., description="A detailed success or failure message.", title="Message")
    success: bool = Field(
        ...,
        description="Whether the upload was successfully cancelled.",
        title="Success",
    )


class SampleCancelUploadSchema(BaseModel):
    sample_id: str = Field(..., title="Sample Id")


class FileType(Enum):
    FASTA = "FASTA"
    FASTQ = "FASTQ"


class NBases(RootModel[int]):
    root: int = Field(..., description="ExcludeFromOpenAPI", ge=1, title="N Bases")


class NLines(RootModel[int]):
    root: int = Field(..., description="ExcludeFromOpenAPI", ge=1, title="N Lines")


class NSequences(RootModel[int]):
    root: int = Field(..., description="ExcludeFromOpenAPI", ge=1, title="N Sequences")


class Size1(RootModel[int]):
    root: int = Field(..., description="ExcludeFromOpenAPI", ge=1, title="Size")


class UncompressedSize(RootModel[int]):
    root: int = Field(..., description="ExcludeFromOpenAPI", ge=1, title="Uncompressed Size")


class SampleConfirmUploadSchema(BaseModel):
    file_type: Optional[FileType] = Field(None, description="ExcludeFromOpenAPI", title="File Type")
    md5: Optional[str] = Field(None, description="ExcludeFromOpenAPI", title="Md5")
    n_bases: Optional[NBases] = Field(None, description="ExcludeFromOpenAPI", title="N Bases")
    n_lines: Optional[NLines] = Field(None, description="ExcludeFromOpenAPI", title="N Lines")
    n_sequences: Optional[NSequences] = Field(
        None, description="ExcludeFromOpenAPI", title="N Sequences"
    )
    s3_key: Optional[str] = Field(None, description="ExcludeFromOpenAPI", title="S3 Key")
    sample_headers: Optional[List[str]] = Field(
        None, description="ExcludeFromOpenAPI", title="Sample Headers"
    )
    sample_id: str = Field(..., title="Sample Id")
    sample_sequences: Optional[List[str]] = Field(
        None, description="ExcludeFromOpenAPI", title="Sample Sequences"
    )
    sha256: Optional[str] = Field(None, description="ExcludeFromOpenAPI", title="Sha256")
    size: Optional[Size1] = Field(None, description="ExcludeFromOpenAPI", title="Size")
    uncompressed_md5: Optional[str] = Field(
        None, description="ExcludeFromOpenAPI", title="Uncompressed Md5"
    )
    uncompressed_sha256: Optional[str] = Field(
        None, description="ExcludeFromOpenAPI", title="Uncompressed Sha256"
    )
    uncompressed_size: Optional[UncompressedSize] = Field(
        None, description="ExcludeFromOpenAPI", title="Uncompressed Size"
    )
    upload_type: Literal["standard"] = Field("standard", title="Upload Type")


class SampleDownloadUriSchema(BaseModel):
    download_uri: str = Field(..., description="A pre-signed download link.", title="Download Uri")
    expires_in_hours: int = Field(
        ...,
        description="The number of hours for which `download_uri` is valid.",
        title="Expires In Hours",
    )


class SampleInitMultipartUploadResponse(BaseModel):
    callback_url: str = Field(..., title="Callback Url")
    file_id: str = Field(..., title="File Id")
    paired_end_file_id: Optional[str] = Field(..., title="Paired End File Id")
    s3_bucket: str = Field(..., title="S3 Bucket")
    sample_id: str = Field(..., title="Sample Id")
    upload_aws_access_key_id: str = Field(..., title="Upload Aws Access Key Id")
    upload_aws_secret_access_key: str = Field(..., title="Upload Aws Secret Access Key")


class PairedEndFilename(RootModel[str]):
    root: str = Field(
        ...,
        pattern="^[\\w\\.]+[\\w\\-\\.\\[\\]\\(\\)\\{\\} ]*\\.[\\w\\.]+$",
        title="Paired End Filename",
    )


class SampleInitPreuploadResponse(BaseModel):
    sample_id: str = Field(
        ..., description="The sample ID. Use to confirm the upload.", title="Sample Id"
    )


class SampleInitUploadResponse(BaseModel):
    additional_fields: Optional[Dict[str, Any]] = Field(
        {},
        description="Additional fields to include in the object storage POST request.",
        title="Additional Fields",
    )
    fallback_options: Optional[Dict[str, Any]] = Field(
        None,
        description="Fallback options for the upload. Please contact support for help as needed.",
        title="Fallback Options",
    )
    paired_end_additional_fields: Optional[Dict[str, Any]] = Field(
        {},
        description="Additional fields to include in the object storage POST request for the paired end file (optional).",
        title="Paired End Additional Fields",
    )
    paired_end_upload_url: Optional[str] = Field(
        None,
        description="Object storage location to POST the paired end file to (optional).",
        title="Paired End Upload Url",
    )
    sample_id: str = Field(
        ..., description="The sample ID. Use to confirm the upload.", title="Sample Id"
    )
    upload_url: str = Field(
        ...,
        description="Object storage location to POST the file to.",
        title="Upload Url",
    )


class PairedEndFilename1(RootModel[str]):
    root: str = Field(
        ...,
        description="Optional filename for paired end uploads.",
        pattern="^[\\w\\.]+[\\w\\-\\.\\[\\]\\(\\)\\{\\} ]*\\.[\\w\\.]+$",
        title="Paired End Filename",
    )


class Project(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/projects/[a-f0-9]{16}$")


class Size2(RootModel[int]):
    root: int = Field(..., description="The size of the file in bytes.", ge=0, title="Size")


class SampleRef(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/samples/[a-f0-9]{16}$")


class Metadata(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/metadata/[a-f0-9]{16}$")


class PrimaryClassification(BaseModel):
    field_ref: Optional[str] = Field(
        None, alias="$ref", pattern="^/api/v1/classifications/[a-f0-9]{16}$"
    )


class Tag(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/tags/[a-f0-9]{16}$")


class SequencingBatchSamplesResponse(BaseModel):
    sample: SampleRef = Field(
        ...,
        description="The sample object associated with the tube barcode. Note this may be in a pending upload state if the lab has not finished processing the physical sample.",
    )
    tube_barcode: str = Field(
        ...,
        description="The tube or container barcode for the sample sent to the lab.",
        title="Tube Barcode",
    )


class Status2(Enum):
    registered = "registered"
    shipped_to_lab = "shipped_to_lab"
    received_at_lab = "received_at_lab"
    extracting = "extracting"
    preparing_library = "preparing_library"
    sequencing = "sequencing"
    done = "done"
    canceled = "canceled"


class SequencingBatchSchema(BaseModel):
    field_uri: str = Field(..., alias="$uri", title="$Uri")
    batch_number: str = Field(..., description="A unique batch number.", title="Batch Number")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    name: Optional[str] = Field(
        ..., description="A human-readable name for the sequencing batch.", title="Name"
    )
    owner: Owner = Field(
        ..., description="The user that created the sequencing batch.", title="users"
    )
    status: Status2 = Field(
        ..., description="The current status of the sequencing batch.", title="Status"
    )


class SequencingDepth(Enum):
    Standard = "Standard"
    Deep = "Deep"


class SequencingLibraryType(Enum):
    WGS = "WGS"
    Targeted_16S = "Targeted/16S"
    Other = "Other"


class SequencingPlatform(Enum):
    field_454_sequencing = "454 sequencing"
    field_454_GS_FLX = "454 GS FLX"
    field_454_GS_FLX_Titanium = "454 GS FLX Titanium"
    Illumina = "Illumina"
    Illumina_Genome_Analyzer_II = "Illumina Genome Analyzer II"
    Illumina_HiSeq = "Illumina HiSeq"
    Illumina_HiSeq_1500 = "Illumina HiSeq 1500"
    Illumina_HiSeq_2000 = "Illumina HiSeq 2000"
    Illumina_HiSeq_2500 = "Illumina HiSeq 2500"
    Illumina_HiSeq_3000 = "Illumina HiSeq 3000"
    Illumina_HiSeq_4000 = "Illumina HiSeq 4000"
    Illumina_HiSeq_X = "Illumina HiSeq X"
    Illumina_iSeq_100 = "Illumina iSeq 100"
    Illumina_MiniSeq = "Illumina MiniSeq"
    Illumina_MiSeq = "Illumina MiSeq"
    Illumina_NextSeq = "Illumina NextSeq"
    Illumina_NextSeq_500 = "Illumina NextSeq 500"
    Illumina_NextSeq_550 = "Illumina NextSeq 550"
    Illumina_NovaSeq = "Illumina NovaSeq"
    Illumina_NovaSeq_5000 = "Illumina NovaSeq 5000"
    Illumina_NovaSeq_6000 = "Illumina NovaSeq 6000"
    BGISEQ = "BGISEQ"
    BGISEQ_50 = "BGISEQ 50"
    Element = "Element"
    Element_AVITI = "Element AVITI"
    Ion = "Ion"
    Ion_S5 = "Ion S5"
    Ion_S5_XL = "Ion S5 XL"
    Ion_PGM = "Ion PGM"
    Ion_Proton = "Ion Proton"
    Ion_Torrent = "Ion Torrent"
    Oxford_Nanopore = "Oxford Nanopore"
    Oxford_Nanopore_GridION_X5 = "Oxford Nanopore GridION X5"
    Oxford_Nanopore_MinION = "Oxford Nanopore MinION"
    Oxford_Nanopore_PromethION = "Oxford Nanopore PromethION"
    PacBio = "PacBio"
    PacBio_RS_II = "PacBio RS II"
    PacBio_Sequel = "PacBio Sequel"
    PacBio_Sequel_II_System = "PacBio Sequel II System"
    PacBio_Revio = "PacBio Revio"
    PacBio_Onso = "PacBio Onso"
    SOLiD = "SOLiD"
    Solexa_Genome_Analyzer = "Solexa Genome Analyzer"
    Sanger = "Sanger"
    Other = "Other"


class SequencingSampleType(Enum):
    Isolate = "Isolate"
    Metagenomic = "Metagenomic"
    Other = "Other"


class SpecimenTypeNoDna(Enum):
    Human_stool = "Human stool"
    Microbial_cell_culture = "Microbial cell culture"


class TagCreateSchema(BaseModel):
    name: str = Field(
        ...,
        description="The tag label or name. Name must be 30 characters or fewer.",
        max_length=30,
        title="Name",
    )
    sample: SampleRef = Field(..., description="The sample to tag.")


class TagRef(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/tags/[a-f0-9]{16}$")


class TagSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/tags/0d77065796f8d173"],
        pattern="^/api/v1/tags/[a-f0-9]{16}$",
        title="$Uri",
    )
    name: str = Field(
        ...,
        description="The tag label or name. Name must be 30 characters or fewer.",
        max_length=30,
        title="Name",
    )


class UserFacingDataStatus(Enum):
    awaiting_data = "awaiting_data"
    importing = "importing"
    validating = "validating"
    failed_validation = "failed_validation"
    available = "available"
    deleted = "deleted"


class UserRef(BaseModel):
    field_ref: Optional[str] = Field(None, alias="$ref", pattern="^/api/v1/users/[a-f0-9]{16}$")


class UserSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/users/0d77065796f8d173"],
        pattern="^/api/v1/users/[a-f0-9]{16}$",
        title="$Uri",
    )
    email: Optional[str] = Field(..., title="Email")


class WebhookSubscriptionSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/webhooks/0d77065796f8d173"],
        pattern="^/api/v1/webhooks/[a-f0-9]{16}$",
        title="$Uri",
    )
    api_version: str = Field(..., title="Api Version")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    enabled: bool = Field(..., title="Enabled")
    event_type: str = Field(..., title="Event Type")
    post_url: str = Field(..., title="Post Url")


class FieldBinnedDepth(BaseModel):
    contig_id: str = Field(..., title="Contig Id")
    depths: List[int] = Field(..., title="Depths")
    length: int = Field(..., ge=1, title="Length")


class FieldCoverage(BaseModel):
    binned_depths: List[FieldBinnedDepth] = Field(..., title="Binned Depths")
    binned_window_width: str = Field(..., title="Binned Window Width")


class FieldFunctionalFilteredResultsRow(BaseModel):
    id: str = Field(..., title="Id")
    name: Optional[str] = Field(None, title="Name")
    taxon_id: Optional[str] = Field(None, title="Taxon Id")
    taxon_name: Optional[str] = Field(None, title="Taxon Name")
    value: float = Field(..., title="Value")


class FieldFunctionalResultsRow(BaseModel):
    group_name: str = Field(..., title="Group Name")
    id: str = Field(..., title="Id")
    metric: str = Field(..., title="Metric")
    name: Optional[str] = Field(None, title="Name")
    taxa_stratified: bool = Field(..., title="Taxa Stratified")
    taxon_id: Optional[str] = Field(None, title="Taxon Id")
    taxon_name: Optional[str] = Field(None, title="Taxon Name")
    value: float = Field(..., title="Value")


class FieldRegisterSampleSchema(BaseModel):
    sequencing_depth: SequencingDepth
    specimen_type: SpecimenTypeNoDna
    tube_barcode: str = Field(..., title="Tube Barcode")


class Abundance(RootModel[float]):
    root: float = Field(..., ge=0.0, le=1.01, title="Abundance")


class AbundanceWChildren(RootModel[float]):
    root: float = Field(..., ge=0.0, le=1.01, title="Abundance W Children")


class FieldTaxonomicResults(BaseModel):
    abundance: Optional[Abundance] = Field(..., title="Abundance")
    abundance_w_children: Optional[AbundanceWChildren] = Field(..., title="Abundance W Children")
    name: str = Field(..., title="Name")
    parent_tax_id: Optional[str] = Field(..., title="Parent Tax Id")
    rank: str = Field(..., title="Rank")
    readcount: int = Field(..., ge=0, title="Readcount")
    readcount_w_children: int = Field(..., ge=0, title="Readcount W Children")
    tax_id: str = Field(..., title="Tax Id")


class FieldTaxonomicResultsRaw(BaseModel):
    abundance: Optional[Abundance] = Field(..., title="Abundance")
    abundance_w_children: Optional[AbundanceWChildren] = Field(..., title="Abundance W Children")
    n_kmers: int = Field(..., ge=0, title="N Kmers")
    n_unique_kmers: int = Field(..., ge=0, title="N Unique Kmers")
    name: str = Field(..., title="Name")
    parent_tax_id: Optional[str] = Field(..., title="Parent Tax Id")
    rank: str = Field(..., title="Rank")
    readcount: int = Field(..., ge=0, title="Readcount")
    readcount_w_children: int = Field(..., ge=0, title="Readcount W Children")
    tax_id: str = Field(..., title="Tax Id")


class FieldTubeAndSampleSchema(BaseModel):
    sample: SampleRef = Field(
        ...,
        description="The sample object associated with the tube barcode. Note this may be in a pending upload state if the lab has not finished processing the physical sample.",
    )
    tube_barcode: str = Field(
        ...,
        description="The tube or container barcode for the sample sent to the lab.",
        title="Tube Barcode",
    )


class AlignmentResultsResponse(BaseModel):
    assembly_accession: Optional[str] = Field(None, title="Assembly Accession")
    assembly_id: str = Field(..., title="Assembly Id")
    average_coverage: float = Field(..., title="Average Coverage")
    average_identity: float = Field(..., title="Average Identity")
    coverage: FieldCoverage
    genome_id: Optional[str] = Field(None, title="Genome Id")
    genome_name: Optional[str] = Field(None, title="Genome Name")
    genome_taxon_id: Optional[str] = Field(None, title="Genome Taxon Id")
    genome_taxon_name: Optional[str] = Field(None, title="Genome Taxon Name")
    median_depth: float = Field(..., title="Median Depth")
    n_mapped: Optional[int] = Field(None, title="N Mapped")
    n_reads: Optional[int] = Field(None, title="N Reads")


class AlignmentSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/alignments/0d77065796f8d173"],
        pattern="^/api/v1/alignments/[a-f0-9]{16}$",
        title="$Uri",
    )
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")


class AnalysisFileDetailsResponse(BaseModel):
    files: List[AnalysisFileDetailsSchema] = Field(
        ..., description="A list of output files.", title="Files"
    )


class AnalysisSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/analyses/0d77065796f8d173"],
        pattern="^/api/v1/analyses/[a-f0-9]{16}$",
        title="$Uri",
    )
    analysis_type: str = Field(..., title="Analysis Type")
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")
    updated_at: Optional[str] = Field(
        None,
        description="Timestamp for when the object was last updated on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Updated At",
    )


class ClassificationRawResultsResponse(BaseModel):
    host_tax_ids: List[str] = Field(..., title="Host Tax Ids")
    n_reads: int = Field(..., ge=1, title="N Reads")
    table: List[FieldTaxonomicResultsRaw] = Field(..., title="Table")


class ClassificationResultsResponse(BaseModel):
    host_tax_ids: List[str] = Field(..., title="Host Tax Ids")
    n_reads: int = Field(..., ge=1, title="N Reads")
    table: List[FieldTaxonomicResults] = Field(..., title="Table")


class ClassificationSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/classifications/0d77065796f8d173"],
        pattern="^/api/v1/classifications/[a-f0-9]{16}$",
        title="$Uri",
    )
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")


class ControlSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/controls/0d77065796f8d173"],
        pattern="^/api/v1/controls/[a-f0-9]{16}$",
        title="$Uri",
    )
    complete: Optional[bool] = Field(False, title="Complete")
    cost: Optional[CostSchema] = Field(..., description="ExcludeFromOpenAPI")
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    dependencies: List[Dependency] = Field(
        ..., description="ExcludeFromOpenAPI", title="Dependencies"
    )
    draft: bool = Field(..., description="ExcludeFromOpenAPI", title="Draft")
    error_msg: Optional[ErrorMsg] = Field(
        None,
        description="The error message from the analysis, if it failed.",
        title="Error Msg",
    )
    job: Job = Field(
        ...,
        description='A reference to the versioned job underlying the analysis, e.g., `{"$ref": "/api/v1/jobs/d512cb556241440f"}`.',
        title="jobs",
    )
    job_args: Optional[Dict[str, Any]] = Field(
        {},
        description="The arguments passed into this analysis (can be `null`).",
        title="Job Args",
    )
    sample: Sample = Field(
        ...,
        description='A reference to the sample underlying the analysis, e.g., `{"$ref": "/api/v1/sample/0ee172af60e84f61"}`.',
        title="samples",
    )
    success: Optional[bool] = Field(False, title="Success")


class DocumentAddUserSchema(BaseModel):
    user: UserRef


class DocumentConfirmUploadResponse(BaseModel):
    document: DocumentRef = Field(..., description="A reference to the uploaded document.")
    message: str = Field(..., description="A success or error message.", title="Message")
    success: bool = Field(..., description="Whether the upload was successful.", title="Success")


class FunctionalFilteredResultsResponse(BaseModel):
    n_mapped: int = Field(..., ge=0, title="N Mapped")
    n_reads: int = Field(..., ge=0, title="N Reads")
    table: List[FieldFunctionalFilteredResultsRow] = Field(..., title="Table")


class FunctionalResultsResponse(BaseModel):
    n_mapped: int = Field(..., ge=0, title="N Mapped")
    n_reads: int = Field(..., ge=0, title="N Reads")
    table: List[FieldFunctionalResultsRow] = Field(..., title="Table")


class InlineMetadata(BaseModel):
    custom: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary metadata is supported as part of a custom object. custom has two constraints: (1) it must have a depth of one (i.e., no nested records); and (2) only strings, numbers, boolean, and null values are supported as values. Example: `{"lab_tech": "Linus Pauling", "amplicon_scheme": "V3-V4"}`',
        title="Custom",
    )
    date_collected: Optional[str] = Field(
        None,
        description="Timestamp for when the sample was collected.",
        title="Date Collected",
    )
    date_sequenced: Optional[str] = Field(
        None,
        description="Timestamp for when the sample was sequenced.",
        title="Date Sequenced",
    )
    description: Optional[str] = Field(None, title="Description")
    external_sample_id: Optional[str] = Field(
        None,
        description="An arbitrary external sample ID, e.g., an ID in a LIMS. Up to 60 characters.",
        examples=["a1b2c3d4e5f67890"],
        title="External Sample Id",
    )
    library_type: Optional[SequencingLibraryType] = Field(
        None, description="An enum with the sample library type."
    )
    location_lat: Optional[LocationLat] = Field(
        None,
        description="The latitude `(-90.0-90.0)` of the sample location. By convention, we recommend using this for the location in which the physical specimen was collected.",
        title="Location Lat",
    )
    location_lon: Optional[LocationLon] = Field(
        None,
        description="The longitude `(-180.0-180.0)` of the sample location.",
        title="Location Lon",
    )
    location_string: Optional[LocationString] = Field(None, title="Location String")
    name: Optional[Name] = Field(None, title="Name")
    platform: Optional[SequencingPlatform] = Field(
        None, description="An enum with the name of the sequencing platform."
    )
    sample_type: Optional[SequencingSampleType] = Field(
        None, description="An enum with the sample type."
    )
    starred: Optional[bool] = Field(
        False,
        description="Whether the sample has been starred by the user within the One Codex web application.",
        title="Starred",
    )


class JobRunAnalysisSchema(BaseModel):
    dependencies: Optional[List[DependencyOverrideSchema]] = Field(
        None,
        description="Override the analysis dependencies for this run with provided dependencies",
        title="Dependencies",
    )
    job_args: Optional[Dict[str, Any]] = Field(..., title="Job Args")
    populate_default_arguments: Optional[bool] = Field(True, title="Populate Default Arguments")
    sample: SampleRef


class MetadataPatchSchema(BaseModel):
    custom: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary metadata is supported as part of a custom object. custom has two constraints: (1) it must have a depth of one (i.e., no nested records); and (2) only strings, numbers, boolean, and null values are supported as values. Example: `{"lab_tech": "Linus Pauling", "amplicon_scheme": "V3-V4"}`',
        title="Custom",
    )
    date_collected: Optional[str] = Field(
        None,
        description="Timestamp for when the sample was collected.",
        title="Date Collected",
    )
    date_sequenced: Optional[str] = Field(
        None,
        description="Timestamp for when the sample was sequenced.",
        title="Date Sequenced",
    )
    description: Optional[str] = Field(None, title="Description")
    external_sample_id: Optional[str] = Field(
        None,
        description="An arbitrary external sample ID, e.g., an ID in a LIMS. Up to 60 characters.",
        examples=["a1b2c3d4e5f67890"],
        title="External Sample Id",
    )
    library_type: Optional[SequencingLibraryType] = Field(
        None, description="An enum with the sample library type."
    )
    location_lat: Optional[LocationLat] = Field(
        None,
        description="The latitude `(-90.0-90.0)` of the sample location. By convention, we recommend using this for the location in which the physical specimen was collected.",
        title="Location Lat",
    )
    location_lon: Optional[LocationLon] = Field(
        None,
        description="The longitude `(-180.0-180.0)` of the sample location.",
        title="Location Lon",
    )
    location_string: Optional[LocationString] = Field(None, title="Location String")
    name: Optional[Name] = Field(None, title="Name")
    platform: Optional[SequencingPlatform] = Field(
        None, description="An enum with the name of the sequencing platform."
    )
    sample_type: Optional[SequencingSampleType] = Field(
        None, description="An enum with the sample type."
    )
    starred: Optional[bool] = Field(
        False,
        description="Whether the sample has been starred by the user within the One Codex web application.",
        title="Starred",
    )


class MetadataSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/metadata/0d77065796f8d173"],
        pattern="^/api/v1/metadata/[a-f0-9]{16}$",
        title="$Uri",
    )
    custom: Optional[Dict[str, Any]] = Field(
        {},
        description='Arbitrary metadata is supported as part of a custom object. custom has two constraints: (1) it must have a depth of one (i.e., no nested records); and (2) only strings, numbers, boolean, and null values are supported as values. Example: `{"lab_tech": "Linus Pauling", "amplicon_scheme": "V3-V4"}`',
        title="Custom",
    )
    date_collected: Optional[str] = Field(
        None,
        description="Timestamp for when the sample was collected.",
        title="Date Collected",
    )
    date_sequenced: Optional[str] = Field(
        None,
        description="Timestamp for when the sample was sequenced.",
        title="Date Sequenced",
    )
    description: Optional[str] = Field(None, title="Description")
    external_sample_id: Optional[str] = Field(
        None,
        description="An arbitrary external sample ID, e.g., an ID in a LIMS. Up to 60 characters.",
        examples=["a1b2c3d4e5f67890"],
        title="External Sample Id",
    )
    library_type: Optional[SequencingLibraryType] = Field(
        None, description="An enum with the sample library type."
    )
    location_lat: Optional[LocationLat] = Field(
        None,
        description="The latitude `(-90.0-90.0)` of the sample location. By convention, we recommend using this for the location in which the physical specimen was collected.",
        title="Location Lat",
    )
    location_lon: Optional[LocationLon] = Field(
        None,
        description="The longitude `(-180.0-180.0)` of the sample location.",
        title="Location Lon",
    )
    location_string: Optional[LocationString] = Field(None, title="Location String")
    name: Optional[Name] = Field(None, title="Name")
    platform: Optional[SequencingPlatform] = Field(
        None, description="An enum with the name of the sequencing platform."
    )
    sample: Sample = Field(..., description="The sample the metadata belongs to.", title="samples")
    sample_type: Optional[SequencingSampleType] = Field(
        None, description="An enum with the sample type."
    )
    starred: Optional[bool] = Field(
        False,
        description="Whether the sample has been starred by the user within the One Codex web application.",
        title="Starred",
    )
    updated_at: Optional[str] = Field(
        None,
        description="Timestamp for when the object was last updated on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Updated At",
    )


class ProjectAddUserSchema(BaseModel):
    permissions: List[str] = Field(..., title="Permissions")
    user: UserRef


class ProjectGetMembersSchema(BaseModel):
    permissions: List[str] = Field(..., title="Permissions")
    user: UserRef


class ProjectRemoveUserSchema(BaseModel):
    user: UserRef


class SampleConfirmUploadResponse(BaseModel):
    message: str = Field(..., description="A detailed success or failure message.", title="Message")
    sample: SampleRef = Field(..., description="A reference to the `$uri` of the uploaded sample.")
    success: bool = Field(..., description="Whether the upload was successful.", title="Success")


class SampleImportSchema(BaseModel):
    import_type: Literal["url"] = Field("url", title="Import Type")
    metadata: Optional[InlineMetadata] = None
    paired_uri: Optional[str] = Field(None, title="Paired Uri")
    project: Optional[ProjectRef] = None
    tags: Optional[List[InlineTag]] = Field([], title="Tags")
    uri: str = Field(..., title="Uri")


class SampleInitMultipartUploadSchema(BaseModel):
    external_sample_id: Optional[str] = Field(None, title="External Sample Id")
    filename: str = Field(
        ...,
        pattern="^[\\w\\.]+[\\w\\-\\.\\[\\]\\(\\)\\{\\} ]*\\.[\\w\\.]+$",
        title="Filename",
    )
    interleaved: Optional[bool] = Field(False, title="Interleaved")
    metadata: Optional[InlineMetadata] = None
    paired_end_filename: Optional[PairedEndFilename] = Field(None, title="Paired End Filename")
    project: Optional[ProjectRef] = None
    sample_id: Optional[str] = Field(None, title="Sample Id")
    tags: Optional[List[InlineTag]] = Field([], title="Tags")


class SampleInitPreuploadSchema(BaseModel):
    metadata: Optional[InlineMetadata] = None
    project: Optional[ProjectRef] = Field(None, description="An optional project.")
    tags: Optional[List[InlineTag]] = Field([], title="Tags")


class SampleInitUploadSchema(BaseModel):
    external_sample_id: Optional[str] = Field(
        None,
        description="An optional external sample ID (see the Metadata resource) to match against pre-uploaded samples. Returns a 400 if no matching sample is found.",
        title="External Sample Id",
    )
    filename: str = Field(
        ...,
        description="The filename of the sample to be uploaded. FASTA and FASTQ records, optionally gzipped (and ending in .gz or .gzip) are supported. Filenames should only contain alphanumeric characters, dashes, underscores, and periods.",
        pattern="^[\\w\\.]+[\\w\\-\\.\\[\\]\\(\\)\\{\\} ]*\\.[\\w\\.]+$",
        title="Filename",
    )
    interleaved: Optional[bool] = Field(
        None,
        description="Whether the file is interleaved (true) or not (false).",
        title="Interleaved",
    )
    metadata: Optional[InlineMetadata] = Field(
        None, description="An optional metadata object to be added to the sample."
    )
    paired_end_filename: Optional[PairedEndFilename1] = Field(
        None,
        description="Optional filename for paired end uploads.",
        title="Paired End Filename",
    )
    project: Optional[Project] = Field(
        None,
        description="An optional project into which to upload the sample.",
        title="Project",
    )
    sample_id: Optional[str] = Field(
        None,
        description="An optional sample ID to match against pre-uploaded samples. Returns a 400 if no matching sample is found.",
        title="Sample Id",
    )
    size: Optional[Size2] = Field(None, description="The size of the file in bytes.", title="Size")
    tags: Optional[List[InlineTag]] = Field(
        [], description="An array of tags to be added to the sample.", title="Tags"
    )
    upload_type: Literal["standard"] = Field(
        "standard",
        description="The type of upload to initiate. Currently only standard uploads are supported via the init_upload route.",
        title="Upload Type",
    )


class SampleSchema(BaseModel):
    field_uri: str = Field(
        ...,
        alias="$uri",
        examples=["/api/v1/samples/0d77065796f8d173"],
        pattern="^/api/v1/samples/[a-f0-9]{16}$",
        title="$Uri",
    )
    created_at: str = Field(
        ...,
        description="Timestamp for when the object was created on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Created At",
    )
    error_msg: Optional[str] = Field(
        None,
        description="An error message if the sample failed to upload, import, or validate.",
        title="Error Msg",
    )
    filename: Optional[str] = Field(None, description="The sample filename.", title="Filename")
    metadata: Metadata = Field(..., description="A metadata object.", title="metadata")
    owner: Owner = Field(..., description="The owner of the sample.", title="users")
    primary_classification: Optional[PrimaryClassification] = Field(
        ...,
        description="A reference to a Classification for the sample. This will typically be the [One Codex Database](https://docs.onecodex.com/en/articles/3761205-one-codex-database) or [Targeted Loci Database](https://docs.onecodex.com/en/articles/3754219-targeted-loci-database) results as appropriate. Note that samples will not have a `primary_classification` while they are still importing or being uploaded.",
        title="Primary Classification",
    )
    project: Optional[Union[Project, ProjectRef]] = Field(
        None,
        description="The project the sample belongs to (optional).",
        title="Project",
    )
    size: Optional[int] = Field(
        None, description="The size of the uploaded file in bytes.", title="Size"
    )
    status: UserFacingDataStatus = Field(..., description="The status of the sample.")
    tags: Optional[List[Tag]] = Field(
        [],
        description="An (optionally empty) array of references to Tags describing the sample. Tags are an additional unstructured organizational tool that complement Projects and Metadata records.",
        title="Tags",
    )
    updated_at: Optional[str] = Field(
        None,
        description="Timestamp for when the object was last updated on the One Codex platform, encoded as a [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) timestamp.",
        title="Updated At",
    )
    visibility: ApiV1Visibility = Field(
        ...,
        description="The visibility of the sample (affects who can view the sample and its analyses).",
    )


class SampleUpdateSchema(BaseModel):
    model_config = ConfigDict(
        extra="forbid",
    )
    project: Optional[Union[ProjectRef, ProjectSchema]] = Field(None, title="Project")
    tags: Optional[Union[List[TagRef], List[InlineTag]]] = Field([], title="Tags")
    visibility: Optional[ApiV1Visibility] = Field(
        "private",
        description="The visibility of the sample (affects who can view the sample and its analyses).",
    )


class SequencingBatchRegisterResponse(BaseModel):
    batch: SequencingBatchSchema = Field(
        ..., description="The sequencing batch object that was created."
    )
    samples: List[FieldTubeAndSampleSchema] = Field(
        ...,
        description="The sample object associated with the tube barcode. This will be in an `awaiting_data` state until the lab has finished processing the physical sample.",
        title="Samples",
    )


class SequencingBatchRegisterSchema(BaseModel):
    batch_name: str = Field(
        ...,
        description="A human-readable name for the sequencing batch.",
        max_length=100,
        min_length=1,
        title="Batch Name",
    )
    return_tracking_numbers: List[str] = Field(
        ...,
        description="One or more tracking numbers associated with the sample shipment(s) to the lab.",
        max_length=100,
        min_length=1,
        title="Return Tracking Numbers",
    )
    samples: List[FieldRegisterSampleSchema] = Field(
        ...,
        description="The tube or container barcodes, specimen type, and sequencing depth for each sample to be sequenced.",
        max_length=5000,
        min_length=1,
        title="Samples",
    )
